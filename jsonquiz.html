<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>JSON → MCQ (fix y = bug)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:0; background:#f7fafc; color:#111827; }
    header{ padding:12px 16px; background:#0f172a; color:#fff; display:flex; align-items:center; }
    header h1{ margin:0; font-size:16px;}
    .container{ display:flex; gap:12px; padding:12px; height:calc(100vh - 60px); box-sizing:border-box; }
    .pane{ flex:1; display:flex; flex-direction:column; gap:8px; background:#fff; padding:12px; border-radius:8px; box-shadow:0 2px 8px rgba(15,23,42,0.06); overflow:auto;}
    textarea{ width:100%; min-height:220px; font-family:monospace; padding:10px; border:1px solid #e5e7eb; border-radius:6px; white-space:pre-wrap; }
    .btns{ margin-left:auto; display:flex; gap:8px; }
    button{ padding:8px 12px; border-radius:8px; border:none; background:#0ea5a4; color:#052023; font-weight:600; cursor:pointer;}
    button.secondary{ background:#f3f4f6; color:#0f172a; border:1px solid #e6eef8;}
    .question{ padding:10px; border-radius:6px; border:1px dashed #e6eef8; background:#fff; }
    pre#outJson, #txtOutput{ white-space:pre-wrap; background:#fff; border:1px solid #e5e7eb; padding:10px; border-radius:6px; color:#0b1220; max-height:320px; overflow:auto;}
    .meta{ font-size:13px; color:#475569;}
  </style>

  <script>
    window.MathJax = { tex:{ inlineMath:[['$','$'],['\\(','\\)']], packages:['base'] }, svg:{ fontCache:'global' } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
  <header>
    <h1>JSON → MCQ (fix y = bug)</h1>
    <div style="margin-left:auto" class="meta">Generate → Export JSON/TXT</div>
  </header>

  <div class="container">
    <div class="pane" style="min-width:420px; max-width:55%;">
      <div style="display:flex; align-items:center; gap:8px;">
        <strong>JSON input</strong>
        <div class="btns">
          <button id="btnGenerate">Generate</button>
          <button id="btnPretty" class="secondary">Pretty JSON</button>
          <button id="btnReset" class="secondary">Reset</button>
        </div>
      </div>

      <textarea id="jsonInput" spellcheck="false">// Dán JSON ở đây
{
  "type": "mcq",
  "question": "Cho hàm số $y = !a(1,2,3,4)! x^4 + {tinh: -2 * !a! * (!k(1,2,3)! * !k!)} x^2 + !c(1,2,3)!$. Tìm khoảng đồng biến, nghịch biến.",
  "option_a": "Hàm số đồng biến trên $(-\\\\infty; -!k!)$ và $(!k!; +\\\\infty)$.",
  "option_b": "Hàm số nghịch biến trên $(-\\\\infty; -!k!)$ và $(!k!; +\\\\infty)$.",
  "option_c": "Hàm số đồng biến trên $(-!k!; !k!)$.",
  "option_d": "Hàm số nghịch biến trên $(-!k!; !k!)$.",
  "correct_option": "A",
  "explanation": "Ta có $y' = 4!a!x^3 + 2{tinh: -2*!a!*!k!*!k!}x = 2x\\\\left( 2!a!x^2 - 2!a! !k!^2 \\\\right)$.\\\\nGiải $y' = 0$ thu được: $x = 0, \\quad x = \\pm !k!$. Vì $4!a! > 0$, bảng biến thiên có dạng dương – âm – dương – âm – dương."
}
      </textarea>

      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:6px;">
        <div class="meta" id="log"></div>
      </div>
    </div>

    <div class="pane">
      <div style="display:flex; align-items:center; gap:8px;">
        <strong>Rendered question</strong>
        <div style="margin-left:auto"></div>
      </div>

      <div id="renderArea" class="question">
        <div class="meta">Chưa có câu — nhấn Generate.</div>
      </div>

      <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
        <label class="meta">Số JSON (N):</label>
        <input id="numJson" type="number" value="1" min="1" max="200" style="width:72px; padding:6px; border-radius:6px; border:1px solid #e5e7eb;" />
        <button id="btnGenerateJsons" class="secondary">Generate JSONs (N)</button>
        <button id="btnRenderTxtMultiple" class="secondary">Render TXT (N)</button>
      </div>

      <div id="processedJsonPanel" style="margin-top:12px; display:none;">
        <strong>JSON đã xử lý:</strong>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:flex-start;">
          <div style="flex:1"><pre id="outJson"></pre></div>
          <div style="display:flex; flex-direction:column; gap:8px;">
            <button id="downloadJson" class="secondary">Download JSON</button>
          </div>
        </div>
      </div>

      <div id="txtPanel" style="margin-top:12px; display:none;">
        <strong>TXT output:</strong>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:flex-start;">
          <div style="flex:1"><div id="txtOutput" style="min-height:120px;"></div></div>
          <div style="display:flex; flex-direction:column; gap:8px;">
            <button id="downloadTxt" class="secondary">Download TXT</button>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/* === Helpers & parser (fixed to normalize 'y =') === */
function randInt(min,max){min=Math.ceil(min);max=Math.floor(max);return Math.floor(Math.random()*(max-min+1))+min;}
function choose(arr){return arr[Math.floor(Math.random()*arr.length)];}
function safeEval(expr){
  expr = expr.replace(/\^/g,'**');
  if (/[A-Za-z]/.test(expr)) throw new Error('Biểu thức chứa ký tự không hợp lệ: ' + expr);
  if (!/^[0-9+\-*/().\s%]*\*{0,2}[0-9+\-*/().\s%]*$/.test(expr)) throw new Error('Biểu thức chứa ký tự bị cấm: ' + expr);
  return Function('"use strict"; return ('+expr+')')();
}
function preprocessNumberAdjacent(raw){
  return raw.replace(/([+\-]?\d+)\s*!([A-Za-z0-9_]+)([^!]*)!/g, function(_, num, name, params){
    return '{tinh: '+num+' * !'+name+params+'!}';
  });
}

/* Determine if string contains polynomial-like patterns */
function containsPolynomialLike(s){
  if(!s || typeof s !== 'string') return false;
  if (/\$.*?\$/.test(s)) {
    // check inside latex content too
    const matches = s.match(/\$([^$]*)\$/g);
    if(matches) {
      for(const m of matches){
        const inner = m.slice(1,-1);
        if(/\b(x|X)\b/.test(inner) || /\bx\^/.test(inner) || /y\s*=/.test(inner) || /\d+x/.test(inner)) return true;
      }
    }
  }
  if (/\b(x|X)\b/.test(s)) return true;
  if (/\bx\^/.test(s)) return true;
  if (/y\s*=/.test(s)) return true;
  if (/\d+x/.test(s)) return true;
  return false;
}

/* Clean polynomial core: collapse +-, remove 0 terms, reduce 1x -> x */
function cleanPolynomialCore(core){
  core = core.replace(/\u2212/g,'-');
  core = core.replace(/\+\s*-/g,'- ');
  core = core.replace(/(^|[^0-9a-zA-Z])([+\-])\s*/g, function(m,g1,sign){ if(g1===''||g1===undefined) return sign; return ' ' + sign + ' '; });

  const terms = [];
  const termRegex = /([+\-]?)\s*([^+\-]+)/g;
  let tm;
  while((tm = termRegex.exec(core)) !== null){
    let sign = tm[1] ? tm[1].trim() : '+';
    let term = tm[2].trim();
    if(term === '') continue;
    terms.push({sign, term});
  }

  const outTerms = [];
  for(const t of terms){
    let term = t.term;
    let sign = t.sign === '' ? '+' : t.sign;

    const m = term.match(/^([+\-]?\d+(?:\.\d+)?)\s*\*?\s*(x(?:\^\d+)?)$/i) || term.match(/^(x(?:\^\d+)?)/i);
    if(m){
      if(m.length === 3 && m[1] !== undefined && m[2] !== undefined){
        let coeff = Number(m[1]);
        const varPart = m[2];
        if(sign === '-') coeff = -coeff;
        if(Math.abs(coeff) < 1e-9) continue;
        if(Math.abs(coeff) === 1) outTerms.push((coeff < 0 ? '-' : '') + varPart);
        else outTerms.push((coeff < 0 ? '-' : '') + Math.abs(coeff) + varPart);
      } else {
        const varPart = m[0];
        outTerms.push((sign === '-' ? '-' : '') + varPart);
      }
    } else {
      const compact = term.replace(/\s+/g,'');
      if(/[xX]/.test(compact)){
        outTerms.push((sign === '-' ? '-' : '') + term);
      } else {
        const num = Number(term);
        if(!Number.isNaN(num)){
          const val = (sign === '-') ? -num : num;
          if(Math.abs(val) < 1e-9) continue;
          outTerms.push((val < 0 ? '-' : '') + Math.abs(val));
        } else {
          outTerms.push((sign === '-' ? '-' : '') + term);
        }
      }
    }
  }

  if(outTerms.length === 0) return '0';
  let result = '';
  for(let i=0;i<outTerms.length;i++){
    const t = outTerms[i];
    if(i === 0) result += t;
    else {
      if(t[0] === '-') result += ' - ' + t.slice(1);
      else result += ' + ' + t;
    }
  }
  return result;
}

/* Clean strings but carefully preserve and normalize 'y = ' */
function cleanStringPreserveLatex(s){
  if(typeof s !== 'string') return s;
  // split into parts by $...$ blocks
  const parts = [];
  let lastIndex = 0;
  const regex = /\$([^$]*)\$/g;
  let m;
  while((m = regex.exec(s)) !== null){
    const idx = m.index;
    if(idx > lastIndex) parts.push({type:'text', text: s.slice(lastIndex, idx)});
    parts.push({type:'latex', text: m[0], inner: m[1]});
    lastIndex = idx + m[0].length;
  }
  if(lastIndex < s.length) parts.push({type:'text', text: s.slice(lastIndex)});

  const outParts = parts.map(p => {
    if(p.type === 'text'){
      if(containsPolynomialLike(p.text)) return cleanPolynomialInText(p.text);
      return p.text;
    } else {
      // latex block
      const inner = p.inner;
      if(/\b(x|X)\b/.test(inner) || /\bx\^/.test(inner) || /y\s*=/.test(inner) || /\d+x/.test(inner)){
        // normalize any 'y = ...' inside to 'y = ' + cleanedRHS
        let newInner = inner.replace(/(y\s*=\s*)([\s\S]*)/, function(_, lhs, rhs){
          // normalize lhs to exactly 'y = '
          const lhsNorm = 'y = ';
          // clean rhs (we remove trailing $ or internal latex parts carefully)
          // We will clean up to end or until a LaTeX separator like \\ or ; or ,
          const rhsPart = rhs.split(/(\\\\|\\,|;|,|\\n)/)[0];
          const cleanedRhs = cleanPolynomialCore(rhsPart);
          // replace the rhsPart in original rhs to keep extra latex tokens after
          return lhsNorm + cleanedRhs + rhs.slice(rhsPart.length);
        });
        // also try to clean polynomial-like fragments inside inner that are not part of y=
        // Find contiguous polynomial-like substring and clean it
        newInner = newInner.replace(/([+\-]?\s*\d+[^\$]*x[^\$]*)/, function(mm){
          try { return cleanPolynomialCore(mm); } catch(e){ return mm; }
        });
        return '$' + newInner + '$';
      } else {
        return p.text;
      }
    }
  });

  return outParts.join('');
}

function cleanPolynomialInText(s){
  if(/y\s*=/.test(s)){
    return s.replace(/(y\s*=\s*)([\s\S]*)/, function(_, lhs, rhs){
      const lhsNorm = 'y = ';
      // clean rhs up to line end or punctuation
      const rhsPart = rhs.split(/(\n|\\n|;|,)/)[0];
      const cleaned = cleanPolynomialCore(rhsPart);
      return lhsNorm + cleaned + rhs.slice(rhsPart.length);
    });
  } else {
    return cleanPolynomialCore(s);
  }
}

/* === Main parser === */
function parseAndGenerateOnce(rawJsonText){
  rawJsonText = preprocessNumberAdjacent(rawJsonText);
  let data;
  try { data = JSON.parse(rawJsonText); } catch(e) { throw new Error('JSON không hợp lệ: ' + e.message); }
  const vars = {};
  function resolvePlaceholder(name, params){
    if(vars.hasOwnProperty(name) && (!params || params === '')) return vars[name];
    let value;
    if(!params || params.trim() === '') value = randInt(-5,5);
    else {
      const p = params.trim();
      const listMatch = p.match(/^\((.*)\)$/);
      if(listMatch){ const items = listMatch[1].split(',').map(s=>s.trim()).filter(Boolean).map(Number); value = choose(items); }
      else if(p === '#0'){ let v; do{ v = randInt(-10,10);} while(v===0); value = v; }
      else {
        const colon = p.split(':').map(s=>s.trim());
        if(colon.length === 3 && colon[0] === '') value = randInt(Number(colon[1]), Number(colon[2]));
        else if(colon.length === 3) value = randInt(Number(colon[1]), Number(colon[2]));
        else if(colon.length === 2) value = randInt(Number(colon[0]), Number(colon[1]));
        else {
          const byComma = p.split(',').map(s=>s.trim()).filter(Boolean);
          if(byComma.length>1) value = choose(byComma.map(Number));
          else { const n = Number(p); value = Number.isNaN(n) ? randInt(-5,5) : n; }
        }
      }
    }
    vars[name] = value; return value;
  }

  function replaceAndCompute(str){
    if(typeof str !== 'string') return str;
    str = str.replace(/!([A-Za-z0-9_]+)([^!]*)!/g, (s,name,params) => {
      if(!vars.hasOwnProperty(name)) resolvePlaceholder(name, params||'');
      return String(vars[name]);
    });
    str = str.replace(/{tinh:\s*([^}]+)}/g, (s, expr) => {
      let exprSafe = expr.replace(/\^/g,'**').trim();
      exprSafe = exprSafe.replace(/!([A-Za-z0-9_]+)([^!]*)!/g, (ss,n,p)=>{ if(!vars.hasOwnProperty(n)) resolvePlaceholder(n,p||''); return String(vars[n]); });
      try {
        const val = safeEval(exprSafe);
        if(Number.isFinite(val)){
          if(Math.abs(Math.round(val)-val) < 1e-9) return String(Math.round(val));
          return String(parseFloat(val.toFixed(6)).toString());
        }
        return String(val);
      } catch(e){ return '{ERR:' + e.message + '}'; }
    });
    str = str.replace(/\\\\/g,'\\');
    return str;
  }

  function processObject(obj){
    if(typeof obj === 'string') return replaceAndCompute(obj);
    else if(Array.isArray(obj)) return obj.map(processObject);
    else if(obj && typeof obj === 'object'){ const out={}; for(const k of Object.keys(obj)) out[k] = processObject(obj[k]); return out; }
    else return obj;
  }

  const processed = processObject(data);

  function cleanRec(o){
    if(typeof o === 'string'){
      return cleanStringPreserveLatex(o);
    } else if(Array.isArray(o)) return o.map(cleanRec);
    else if(o && typeof o === 'object'){ const out={}; for(const k of Object.keys(o)) out[k] = cleanRec(o[k]); return out; }
    else return o;
  }
  const processedClean = cleanRec(processed);
  return { raw:data, processed, processedClean, vars };
}

/* === Build TXT + render + UI + downloads (same as before) === */
function buildTxtFromProcessed(processedClean, idx){
  function getField(f){ return processedClean[f] || ''; }
  const qraw = getField('question');
  const A = getField('option_a'), B = getField('option_b'), C = getField('option_c'), D = getField('option_d');
  const correct = (processedClean.correct_option || 'A').trim().toUpperCase();
  function mark(letter, text){ return (letter===correct? '*':'') + letter + '. ' + text; }
  const explanation = getField('explanation') || '';
  const header = 'Câu ' + idx + ': ' + qraw;
  const options = [ mark('A',A), mark('B',B), mark('C',C), mark('D',D) ].join('\n');
  return header + '\n' + options + '\nLời giải:\n' + explanation;
}

function renderQuestionToUI(processedClean){
  const container = document.getElementById('renderArea');
  container.innerHTML = '';
  const q = document.createElement('div'); q.className='meta';
  q.innerHTML = '<div style="font-weight:700; margin-bottom:6px;">Câu hỏi:</div>';
  const qText = document.createElement('div'); qText.innerHTML = processedClean.question || '(Không có)';
  q.appendChild(qText); container.appendChild(q);

  const opts = ['option_a','option_b','option_c','option_d'];
  const form = document.createElement('form'); form.id='mcqForm';
  opts.forEach((k,idx)=>{
    if(!processedClean[k]) return;
    const row = document.createElement('label'); row.style.display='flex'; row.style.alignItems='center';
    const radio = document.createElement('input'); radio.type='radio'; radio.name='mcq'; radio.value=String.fromCharCode(65+idx); radio.style.marginRight='8px';
    row.appendChild(radio);
    const span = document.createElement('span'); span.innerHTML = processedClean[k];
    row.appendChild(span);
    form.appendChild(row);
  });
  const containerOpts = document.createElement('div'); containerOpts.className='options'; containerOpts.style.marginTop='12px';
  containerOpts.appendChild(form); container.appendChild(containerOpts);

  const btnShowExp = document.createElement('button'); btnShowExp.type='button'; btnShowExp.className='secondary'; btnShowExp.style.marginTop='10px'; btnShowExp.textContent='Hiện lời giải';
  btnShowExp.onclick = ()=> { const exp = document.getElementById('explanationDiv'); if(exp) exp.style.display = exp.style.display === 'none' ? 'block' : 'none'; };
  container.appendChild(btnShowExp);

  const explanationDiv = document.createElement('div'); explanationDiv.id='explanationDiv'; explanationDiv.className='explanation'; explanationDiv.style.display='none';
  explanationDiv.innerHTML = '<strong>Lời giải:</strong><div style="margin-top:6px;">' + (processedClean.explanation || '') + '</div>';
  container.appendChild(explanationDiv);

  MathJax.typesetPromise();
}

/* UI hooks */
document.getElementById('btnGenerate').addEventListener('click', ()=>{
  const raw = document.getElementById('jsonInput').value;
  const log = document.getElementById('log'); log.textContent='';
  try {
    const res = parseAndGenerateOnce(raw);
    document.getElementById('outJson').textContent = JSON.stringify(res.processedClean, null, 2);
    document.getElementById('processedJsonPanel').style.display = 'block';
    window._lastProcessed = res.processed; window._lastProcessedClean = res.processedClean; window._lastRaw = raw;
    renderQuestionToUI(res.processedClean);
    document.getElementById('txtPanel').style.display = 'none';
    document.getElementById('log').textContent = 'Generated ✓ (y = normalized)';
  } catch(e){
    document.getElementById('log').textContent = 'Error: ' + e.message;
    document.getElementById('renderArea').innerHTML = '<div style="color:#b91c1c">Lỗi: ' + e.message + '</div>';
  }
});

document.getElementById('btnPretty').addEventListener('click', ()=>{
  try { const parsed = JSON.parse(document.getElementById('jsonInput').value); document.getElementById('jsonInput').value = JSON.stringify(parsed,null,2); } catch(e){ alert('JSON không hợp lệ: ' + e.message); }
});
document.getElementById('btnReset').addEventListener('click', ()=>{
  document.getElementById('jsonInput').value = ''; document.getElementById('renderArea').innerHTML = '<div class="meta">Chưa có câu — nhấn Generate.</div>';
  document.getElementById('outJson').textContent = ''; document.getElementById('processedJsonPanel').style.display='none'; document.getElementById('txtPanel').style.display='none';
  document.getElementById('log').textContent=''; window._lastProcessed = null; window._lastProcessedClean = null; window._lastRaw = null;
});

document.getElementById('btnGenerateJsons').addEventListener('click', ()=>{
  const raw = window._lastRaw || document.getElementById('jsonInput').value;
  if(!raw){ alert('Chưa có JSON nguồn. Dán JSON và nhấn Generate trước.'); return; }
  const n = Math.max(1, Math.min(200, Number(document.getElementById('numJson').value) || 1));
  const list = [];
  for(let i=0;i<n;i++){
    try { const r = parseAndGenerateOnce(raw); list.push(r.processedClean); }
    catch(e){ list.push({ error: 'Lỗi sinh câu ' + (i+1) + ': ' + e.message }); }
  }
  document.getElementById('outJson').textContent = JSON.stringify(list, null, 2);
  document.getElementById('processedJsonPanel').style.display = 'block';
  document.getElementById('txtPanel').style.display = 'none';
  document.getElementById('log').textContent = 'Generated ' + n + ' JSONs';
});

document.getElementById('btnRenderTxtMultiple').addEventListener('click', ()=>{
  const raw = window._lastRaw || document.getElementById('jsonInput').value;
  if(!raw){ alert('Chưa có JSON nguồn. Dán JSON và nhấn Generate trước.'); return; }
  const n = Math.max(1, Math.min(200, Number(document.getElementById('numJson').value) || 1));
  const parts = [];
  for(let i=1;i<=n;i++){
    try { const res = parseAndGenerateOnce(raw); parts.push(buildTxtFromProcessed(res.processedClean, i)); }
    catch(e){ parts.push('Lỗi khi sinh câu ' + i + ': ' + e.message); }
  }
  document.getElementById('txtOutput').innerText = parts.join('\n\n---\n\n');
  document.getElementById('txtPanel').style.display = 'block';
  document.getElementById('processedJsonPanel').style.display = 'none';
  document.getElementById('log').textContent = 'Rendered TXT ' + n + ' câu';
});

/* downloads */
function downloadText(filename, text){
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}
document.getElementById('downloadJson').addEventListener('click', ()=>{
  const content = document.getElementById('outJson').textContent;
  if(!content || content.trim()===''){ alert('Không có JSON để tải.'); return; }
  try { const parsed = JSON.parse(content); const text = JSON.stringify(parsed, null, 2); downloadText('questions_' + new Date().toISOString().slice(0,19).replace(/[:T]/g,'-') + '.json', text); }
  catch(e){ downloadText('questions_raw.json', content); }
});
document.getElementById('downloadTxt').addEventListener('click', ()=>{
  const content = document.getElementById('txtOutput').textContent;
  if(!content || content.trim()===''){ alert('Không có TXT để tải.'); return; }
  downloadText('questions_' + new Date().toISOString().slice(0,19).replace(/[:T]/g,'-') + '.txt', content);
});

</script>
</body>
</html>
